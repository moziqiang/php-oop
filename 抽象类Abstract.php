<?php
//**抽象类**：使用abstract关键字修饰的类，表示该类只能被继承，不能被实例化
//
//* 抽象类只是用来规范下属类的基本结构，本身不可被实例化
//* 抽象类只能被实现类继承
//* abstract关键字可以修饰方法，表示方法为抽象方法，抽象方法没有方法体（没有{}）
//  * 抽象方法存在的类必须为抽象类
//  * 继承抽象类的类要么为抽象类，要么实现抽象类里所有的抽象方法
//* 抽象类还可以有其他类该有的任何成员


//1、项目较大，分组完成
//
//2、项目管理者为了确保各组开发的统一性，规范上层架构
//
//3、使用抽象类和抽象方法设定基调（多种抽象类）
//
//4、所有实现类都继承抽象类













//1、基本语法：使用abstract关键字修饰类


# 抽象类
abstract class human{


    //4、abstract关键字还可以用来修饰方法（抽象方法），abstract修饰的方法不能有方法体，而且有抽象方法的类必须声明为抽象类

    # 抽象方法
    abstract public function eat();

    public function show(){} ## 普通方法有方法体

    #5、抽象方法因为要被子类继承实现，所以不能使用private修饰（私有方法不会被继承）
//    abstract private function eat(); # 错误：抽象方法不能私有化

}


//2、抽象类无法被实例化

//$h = new human(); //2、致命错误，抽象类不能被实例化


//3、抽象类只能被继承
//# 子类1：抽象类继承抽象类

abstract class man extends human{} # 正确 ,正常继承


//6、子类继承抽象类后，如果抽象类中有抽象方法，那么子类必须选择自己成为抽象类或者实现抽象方法（所有抽象方法）

# 子类2：子类实现父类所有抽象方法

class boy extends man{
    # 实现从祖父类继承的eat抽象方法

    public function eat()
    {
        echo 'eat';
    }
}


//小结
//1、使用abstract修饰的类叫做抽象类
//
//2、抽象类不可以被实例化，只能被继承
//
//3、因为抽象类无法被实例化，因此私有成员在类中没有实质意义（还需要额外提供受保护或者**公有**方法来实现访问）
//
//4、抽象类的目的是用来规范子类（通常比配抽象方法）
//
//5、abstract还可以修饰方法，称之为抽象方法：抽象方法所在的类必须是抽象类，抽象方法不能有方法体
//
//6、有抽象方法的抽象被继承时子类要么自身是抽象类，要么实现所有抽象方法
//
//7、抽象类这种结构管理，需要耗费较多的架构和初始代码，通常在比较大型或者规范的项目中才会使用